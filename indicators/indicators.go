/*
	import "github.com/jaybutera/gotrade"

	Package indicators provides a range of technical trading indicators.
	All indicators follow the basic structure of:
		- receiving price data,	processing this price data and storing the transformed result.
		- maximum and minimum bounds of the transformed results are calculated automatically.
		- a lookback period indicating the lag between source data and the transformed result.
		- the source data bar from which the indicator is valid

 	Functions are provided for each indicator that provide indicator creation
 	for the following scenarios:

 	Online Usage
		- the data stream length is not known ahead of time, e.g. real time data streams
 	Offline Usage
		- the data stream length is known ahead of time, e.g. historical data streams

	Both scenarios provide the following indicator creation functions
 		* Indicator with default parameters
 		* Indicator with default parameters for attachment to a data stream
 		* Indicator with specified parameters
 		* Indicator with specified parameters for attachment to a data stream
 		* Indicator without storage with specified parameters
			- for use inside other indicators, has no storage of results which is instead
			- provided via a callback when it becomes available for use in the parent indicator.
*/
package indicators

import (
	"errors"
	"github.com/jaybutera/gotrade"
	"math"
)

var (
	ErrSourceDataEmpty                      = errors.New("Source data is empty")
	ErrNotEnoughSourceDataForLookbackPeriod = errors.New("Source data does not contain enough data for the specfied lookback period")
	ErrLookbackPeriodMustBeGreaterThanZero  = errors.New("Lookback period must be greater than 0")
	ErrValueAvailableActionIsNil            = errors.New("A ValueAvailableAction is required")
	ErrDOHLCVDataSelectFuncIsNil            = errors.New("A DOHLCVDataSelectionFunc is required")
	ErrStrBelowMinimum                      = "is less than the minimum"
	ErrStrAboveMaximum                      = "is greater than the maximum"

	// lookback minimum
	MinimumLookbackPeriod int = 0
	// lookback maximum
	MaximumLookbackPeriod int = 100000
)

type Indicator interface {
	// the source data bar number from which this indicator is valid, starts at bar 1.
	ValidFromBar() int
	// the lookback period, if applicable, the amount of lag the indicator displays with regards to the source data.
	GetLookbackPeriod() int
	// the length of the transformed data generated by the indicator.
	Length() int
}

type IndicatorWithTimePeriod interface {
	GetTimePeriod() int
}

type IndicatorWithFloatBounds interface {
	// the minimum bound of the transformed data generated by the indicator.
	MinValue() float64
	// the maximum bound of the transformed data generated by the indicator.
	MaxValue() float64
}

type IndicatorWithIntBounds interface {
	// the minimum bound of the transformed data generated by the indicator.
	MinValue() int64
	// the maximum bound of the transformed data generated by the indicator.
	MaxValue() int64
}

type baseFloatBounds struct {
	minValue float64
	maxValue float64
}

func newBaseFloatBounds() *baseFloatBounds {
	ind := baseFloatBounds{minValue: math.MaxFloat64, maxValue: math.SmallestNonzeroFloat64}
	return &ind
}

func (ind *baseFloatBounds) MinValue() float64 {
	return ind.minValue
}

func (ind *baseFloatBounds) MaxValue() float64 {
	return ind.maxValue
}

func (ind *baseFloatBounds) UpdateMinMax(minCandidate float64, maxCandidate float64) {
	// update the maximum result value
	if maxCandidate > ind.maxValue {
		ind.maxValue = maxCandidate
	}

	// update the minimum result value
	if minCandidate < ind.minValue {
		ind.minValue = minCandidate
	}
}

type baseIntBounds struct {
	minValue int64
	maxValue int64
}

func newBaseIntBounds() *baseIntBounds {
	ind := baseIntBounds{minValue: math.MaxInt64, maxValue: math.MinInt64}
	return &ind
}

func (ind *baseIntBounds) MinValue() int64 {
	return ind.minValue
}

func (ind *baseIntBounds) MaxValue() int64 {
	return ind.maxValue
}

func (ind *baseIntBounds) UpdateMinMax(minCandidate int64, maxCandidate int64) {
	// update the maximum result value
	if maxCandidate > ind.maxValue {
		ind.maxValue = maxCandidate
	}

	// update the minimum result value
	if minCandidate < ind.minValue {
		ind.minValue = minCandidate
	}
}

type baseIndicator struct {
	validFromBar   int
	dataLength     int
	lookbackPeriod int
}

func newBaseIndicator(lookbackPeriod int) *baseIndicator {
	ind := baseIndicator{lookbackPeriod: lookbackPeriod, validFromBar: -1}
	return &ind
}

func (ind *baseIndicator) ValidFromBar() int {
	return ind.validFromBar
}

func (ind *baseIndicator) GetLookbackPeriod() int {
	return ind.lookbackPeriod
}

func (ind *baseIndicator) Length() int {
	return ind.dataLength
}

func (ind *baseIndicator) IncDataLength() {
	ind.dataLength += 1
}

func (ind *baseIndicator) SetValidFromBar(streamBarIndex int) {
	// if the indicator has not yet set a valid from bar
	if ind.validFromBar == -1 {
		// set the streamBarIndex from which this indicator returns valid results
		ind.validFromBar = streamBarIndex
	}
}

type baseIndicatorWithTimePeriod struct {
	timePeriod int
}

type baseIndicatorWithFloatBounds struct {
	*baseIndicator
	*baseFloatBounds
	valueAvailableAction ValueAvailableActionFloat
}

func newBaseIndicatorWithFloatBounds(lookbackPeriod int, valueAvailableAction ValueAvailableActionFloat) *baseIndicatorWithFloatBounds {
	ind := baseIndicatorWithFloatBounds{
		baseIndicator:        newBaseIndicator(lookbackPeriod),
		baseFloatBounds:      newBaseFloatBounds(),
		valueAvailableAction: valueAvailableAction,
	}
	return &ind
}

func (ind *baseIndicatorWithFloatBounds) UpdateIndicatorWithNewValue(newValue float64, streamBarIndex int) {
	// increment the number of results this indicator can be expected to return
	ind.IncDataLength()

	// set the streamBarIndex from which this indicator returns valid results
	ind.SetValidFromBar(streamBarIndex)

	// update the min max data bounds
	ind.UpdateMinMax(newValue, newValue)

	// notify of a new result value though the value available action
	ind.valueAvailableAction(newValue, streamBarIndex)
}

type baseIndicatorWithFloatBoundsAroon struct {
	*baseIndicator
	*baseFloatBounds
	valueAvailableAction ValueAvailableActionAroon
}

func newBaseIndicatorWithFloatBoundsAroon(lookbackPeriod int, valueAvailableAction ValueAvailableActionAroon) *baseIndicatorWithFloatBoundsAroon {
	ind := baseIndicatorWithFloatBoundsAroon{
		baseIndicator:        newBaseIndicator(lookbackPeriod),
		baseFloatBounds:      newBaseFloatBounds(),
		valueAvailableAction: valueAvailableAction,
	}
	return &ind
}

func (ind *baseIndicatorWithFloatBoundsAroon) UpdateIndicatorWithNewValue(newAroonUpValue float64, newAroonDwnValue float64, streamBarIndex int) {
	// increment the number of results this indicator can be expected to return
	ind.IncDataLength()

	// set the streamBarIndex from which this indicator returns valid results
	ind.SetValidFromBar(streamBarIndex)

	// update the min max data bounds
	ind.UpdateMinMax(newAroonDwnValue, newAroonUpValue)

	// notify of a new result value though the value available action
	ind.valueAvailableAction(newAroonUpValue, newAroonDwnValue, streamBarIndex)
}

type baseIndicatorWithFloatBoundsBollinger struct {
	*baseIndicator
	*baseFloatBounds
	valueAvailableAction ValueAvailableActionBollinger
}

func newBaseIndicatorWithFloatBoundsBollinger(lookbackPeriod int, valueAvailableAction ValueAvailableActionBollinger) *baseIndicatorWithFloatBoundsBollinger {
	ind := baseIndicatorWithFloatBoundsBollinger{
		baseIndicator:        newBaseIndicator(lookbackPeriod),
		baseFloatBounds:      newBaseFloatBounds(),
		valueAvailableAction: valueAvailableAction,
	}
	return &ind
}

func (ind *baseIndicatorWithFloatBoundsBollinger) UpdateIndicatorWithNewValue(newUpperBandValue float64, newMiddleBandValue float64, newLowerBandValue float64, streamBarIndex int) {
	// increment the number of results this indicator can be expected to return
	ind.IncDataLength()

	// set the streamBarIndex from which this indicator returns valid results
	ind.SetValidFromBar(streamBarIndex)

	// update the min max data bounds
	ind.UpdateMinMax(newLowerBandValue, newUpperBandValue)

	// notify of a new result value though the value available action
	ind.valueAvailableAction(newUpperBandValue, newMiddleBandValue, newLowerBandValue, streamBarIndex)
}

type baseIndicatorWithFloatBoundsStoch struct {
	*baseIndicator
	*baseFloatBounds
	valueAvailableAction ValueAvailableActionStoch
}

func newBaseIndicatorWithFloatBoundsStoch(lookbackPeriod int, valueAvailableAction ValueAvailableActionStoch) *baseIndicatorWithFloatBoundsStoch {
	ind := baseIndicatorWithFloatBoundsStoch{
		baseIndicator:        newBaseIndicator(lookbackPeriod),
		baseFloatBounds:      newBaseFloatBounds(),
		valueAvailableAction: valueAvailableAction,
	}
	return &ind
}

func (ind *baseIndicatorWithFloatBoundsStoch) UpdateIndicatorWithNewValue(newSlowKValue float64, newSlowDValue float64, streamBarIndex int) {
	// increment the number of results this indicator can be expected to return
	ind.IncDataLength()

	// set the streamBarIndex from which this indicator returns valid results
	ind.SetValidFromBar(streamBarIndex)

	var max = math.Max(newSlowKValue, newSlowDValue)
	var min = math.Min(newSlowKValue, newSlowDValue)

	// update the min max data bounds
	ind.UpdateMinMax(min, max)

	// notify of a new result value though the value available action
	ind.valueAvailableAction(newSlowKValue, newSlowDValue, streamBarIndex)
}

type baseIndicatorWithIntBounds struct {
	*baseIndicator
	*baseIntBounds
	valueAvailableAction ValueAvailableActionInt
}

func newBaseIndicatorWithIntBounds(lookbackPeriod int, valueAvailableAction ValueAvailableActionInt) *baseIndicatorWithIntBounds {
	ind := baseIndicatorWithIntBounds{
		baseIndicator:        newBaseIndicator(lookbackPeriod),
		baseIntBounds:        newBaseIntBounds(),
		valueAvailableAction: valueAvailableAction,
	}
	return &ind
}

func (ind *baseIndicatorWithIntBounds) UpdateIndicatorWithNewValue(newValue int64, streamBarIndex int) {
	// increment the number of results this indicator can be expected to return
	ind.IncDataLength()

	// set the streamBarIndex from which this indicator returns valid results
	ind.SetValidFromBar(streamBarIndex)

	// update the min max data bounds
	ind.UpdateMinMax(newValue, newValue)

	// notify of a new result value though the value available action
	ind.valueAvailableAction(newValue, streamBarIndex)
}

type ValueAvailableActionFloat func(dataItem float64, streamBarIndex int)
type ValueAvailableActionInt func(dataItem int64, streamBarIndex int)
type ValueAvailableActionDOHLCV func(dataItem gotrade.DOHLCV, streamBarIndex int)
type ValueAvailableActionBollinger func(dataItemUpperBand float64, dataItemMiddleBand float64, dataItemLowerBand float64, streamBarIndex int)
type ValueAvailableActionMacd func(dataItemMacd float64, dataItemSignal float64, dataItemHistogram float64, streamBarIndex int)
type ValueAvailableActionAroon func(dataItemAroonUp float64, dataItemAroonDown float64, streamBarIndex int)
type ValueAvailableActionStoch func(dataItemK float64, dataItemD float64, streamBarIndex int)
type ValueAvailableActionLinearReg func(dataItem float64, slope float64, intercept float64, streamBarIndex int)
